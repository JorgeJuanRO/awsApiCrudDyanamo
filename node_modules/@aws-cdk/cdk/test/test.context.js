"use strict";
const cxapi = require("@aws-cdk/cx-api");
const lib_1 = require("../lib");
/**
 * Get the expected context key from a stack with missing parameters
 */
function expectedContextKey(stack) {
    const missing = lib_1.ConstructNode.synth(stack.node).manifest.missing;
    if (!missing || missing.length !== 1) {
        throw new Error(`Expecting assembly to include a single missing context report`);
    }
    return missing[0].key;
}
module.exports = {
    'AvailabilityZoneProvider returns a list with dummy values if the context is not available'(test) {
        const stack = new lib_1.Stack(undefined, 'TestStack', { env: { account: '12345', region: 'us-east-1' } });
        const azs = lib_1.Context.getAvailabilityZones(stack);
        test.deepEqual(azs, ['dummy1a', 'dummy1b', 'dummy1c']);
        test.done();
    },
    'AvailabilityZoneProvider will return context list if available'(test) {
        const stack = new lib_1.Stack(undefined, 'TestStack', { env: { account: '12345', region: 'us-east-1' } });
        const before = lib_1.Context.getAvailabilityZones(stack);
        test.deepEqual(before, ['dummy1a', 'dummy1b', 'dummy1c']);
        const key = expectedContextKey(stack);
        stack.node.setContext(key, ['us-east-1a', 'us-east-1b']);
        const azs = lib_1.Context.getAvailabilityZones(stack);
        test.deepEqual(azs, ['us-east-1a', 'us-east-1b']);
        test.done();
    },
    'AvailabilityZoneProvider will complain if not given a list'(test) {
        const stack = new lib_1.Stack(undefined, 'TestStack', { env: { account: '12345', region: 'us-east-1' } });
        const before = lib_1.Context.getAvailabilityZones(stack);
        test.deepEqual(before, ['dummy1a', 'dummy1b', 'dummy1c']);
        const key = expectedContextKey(stack);
        stack.node.setContext(key, 'not-a-list');
        test.throws(() => lib_1.Context.getAvailabilityZones(stack));
        test.done();
    },
    'ContextProvider consistently generates a key'(test) {
        const stack = new lib_1.Stack(undefined, 'TestStack', { env: { account: '12345', region: 'us-east-1' } });
        const provider = new lib_1.ContextProvider(stack, 'ssm', {
            parameterName: 'foo',
            anyStringParam: 'bar',
        });
        const key = provider.key;
        test.deepEqual(key, 'ssm:account=12345:anyStringParam=bar:parameterName=foo:region=us-east-1');
        const complex = new lib_1.ContextProvider(stack, 'vpc', {
            cidrBlock: '192.168.0.16',
            tags: { Name: 'MyVPC', Env: 'Preprod' },
            igw: false,
        });
        const complexKey = complex.key;
        test.deepEqual(complexKey, 'vpc:account=12345:cidrBlock=192.168.0.16:igw=false:region=us-east-1:tags.Env=Preprod:tags.Name=MyVPC');
        test.done();
    },
    'Key generation can contain arbitrarily deep structures'(test) {
        // GIVEN
        const stack = new lib_1.Stack(undefined, 'TestStack', { env: { account: '12345', region: 'us-east-1' } });
        // WHEN
        const provider = new lib_1.ContextProvider(stack, 'provider', {
            list: [
                { key: 'key1', value: 'value1' },
                { key: 'key2', value: 'value2' },
            ],
        });
        // THEN
        test.equals(provider.key, 'provider:account=12345:list.0.key=key1:list.0.value=value1:list.1.key=key2:list.1.value=value2:region=us-east-1');
        test.done();
    },
    'SSM parameter provider will return context values if available'(test) {
        const stack = new lib_1.Stack(undefined, 'TestStack', { env: { account: '12345', region: 'us-east-1' } });
        lib_1.Context.getSsmParameter(stack, 'test');
        const key = expectedContextKey(stack);
        stack.node.setContext(key, 'abc');
        const ssmp = lib_1.Context.getSsmParameter(stack, 'test');
        const azs = stack.resolve(ssmp);
        test.deepEqual(azs, 'abc');
        test.done();
    },
    'Return default values if "env" is undefined to facilitate unit tests, but also expect metadata to include "error" messages'(test) {
        const app = new lib_1.App();
        const stack = new lib_1.Stack(app, 'test-stack');
        const child = new lib_1.Construct(stack, 'ChildConstruct');
        test.deepEqual(lib_1.Context.getAvailabilityZones(stack), ['dummy1a', 'dummy1b', 'dummy1c']);
        test.deepEqual(lib_1.Context.getSsmParameter(child, 'foo'), 'dummy');
        const assembly = app.synth();
        const output = assembly.getStack('test-stack');
        const metadata = output.manifest.metadata || {};
        const azError = metadata['/test-stack'].find(x => x.type === cxapi.ERROR_METADATA_KEY);
        const ssmError = metadata['/test-stack/ChildConstruct'].find(x => x.type === cxapi.ERROR_METADATA_KEY);
        test.ok(azError && azError.data.includes('Cannot determine scope for context provider availability-zones'));
        test.ok(ssmError && ssmError.data.includes('Cannot determine scope for context provider ssm'));
        test.done();
    },
    'fails if region is not specified in CLI context'(test) {
        // GIVEN
        const stack = new lib_1.Stack();
        // WHEN
        stack.node.setContext(cxapi.DEFAULT_ACCOUNT_CONTEXT_KEY, '1111111111');
        // THEN
        test.throws(() => lib_1.Context.getAvailabilityZones(stack), /A region must be specified in order to obtain environmental context: availability-zones/);
        test.done();
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5jb250ZXh0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidGVzdC5jb250ZXh0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSx5Q0FBMEM7QUFFMUMsZ0NBQXdGO0FBNkh4Rjs7R0FFRztBQUNILFNBQVMsa0JBQWtCLENBQUMsS0FBWTtJQUN0QyxNQUFNLE9BQU8sR0FBRyxtQkFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztJQUNqRSxJQUFJLENBQUMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQUMsK0RBQStELENBQUMsQ0FBQztLQUNsRjtJQUNELE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUN4QixDQUFDO0FBcElELGlCQUFTO0lBQ1AsMkZBQTJGLENBQUMsSUFBVTtRQUNwRyxNQUFNLEtBQUssR0FBRyxJQUFJLFdBQUssQ0FBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3BHLE1BQU0sR0FBRyxHQUFHLGFBQU8sQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVoRCxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUN2RCxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDZCxDQUFDO0lBRUQsZ0VBQWdFLENBQUMsSUFBVTtRQUN6RSxNQUFNLEtBQUssR0FBRyxJQUFJLFdBQUssQ0FBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsV0FBVyxF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LFFBQVEsQ0FBQyxpREFBaUQsQ0FBQyxDQUFDLENBQUM7UUFFM0csSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2QsQ0FBQztJQUVELGlEQUFpRCxDQUFDLElBQVU7UUFDMUQsUUFBUTtRQUNSLE1BQU0sS0FBSyxHQUFHLElBQUksV0FBSyxFQUFFLENBQUM7UUFFMUIsT0FBTztRQUNQLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQywyQkFBMkIsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUV2RSxPQUFPO1FBQ1AsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxhQUFPLENBQUMsb0JBQW9CLENBQUMsS0FBSyxDQUFDLEVBQUUseUZBQXlGLENBQUMsQ0FBQztRQUNsSixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDZCxDQUFDO0NBQ0YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjeGFwaSA9IHJlcXVpcmUoJ0Bhd3MtY2RrL2N4LWFwaScpO1xuaW1wb3J0IHsgVGVzdCB9IGZyb20gJ25vZGV1bml0JztcbmltcG9ydCB7IEFwcCwgQ29uc3RydWN0LCBDb25zdHJ1Y3ROb2RlLCBDb250ZXh0LCBDb250ZXh0UHJvdmlkZXIsIFN0YWNrIH0gZnJvbSAnLi4vbGliJztcblxuZXhwb3J0ID0ge1xuICAnQXZhaWxhYmlsaXR5Wm9uZVByb3ZpZGVyIHJldHVybnMgYSBsaXN0IHdpdGggZHVtbXkgdmFsdWVzIGlmIHRoZSBjb250ZXh0IGlzIG5vdCBhdmFpbGFibGUnKHRlc3Q6IFRlc3QpIHtcbiAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjayh1bmRlZmluZWQsICdUZXN0U3RhY2snLCB7IGVudjogeyBhY2NvdW50OiAnMTIzNDUnLCByZWdpb246ICd1cy1lYXN0LTEnIH0gfSk7XG4gICAgY29uc3QgYXpzID0gQ29udGV4dC5nZXRBdmFpbGFiaWxpdHlab25lcyhzdGFjayk7XG5cbiAgICB0ZXN0LmRlZXBFcXVhbChhenMsIFsnZHVtbXkxYScsICdkdW1teTFiJywgJ2R1bW15MWMnXSk7XG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ0F2YWlsYWJpbGl0eVpvbmVQcm92aWRlciB3aWxsIHJldHVybiBjb250ZXh0IGxpc3QgaWYgYXZhaWxhYmxlJyh0ZXN0OiBUZXN0KSB7XG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2sodW5kZWZpbmVkLCAnVGVzdFN0YWNrJywgeyBlbnY6IHsgYWNjb3VudDogJzEyMzQ1JywgcmVnaW9uOiAndXMtZWFzdC0xJyB9IH0pO1xuICAgIGNvbnN0IGJlZm9yZSA9IENvbnRleHQuZ2V0QXZhaWxhYmlsaXR5Wm9uZXMoc3RhY2spO1xuICAgIHRlc3QuZGVlcEVxdWFsKGJlZm9yZSwgWyAnZHVtbXkxYScsICdkdW1teTFiJywgJ2R1bW15MWMnIF0pO1xuICAgIGNvbnN0IGtleSA9IGV4cGVjdGVkQ29udGV4dEtleShzdGFjayk7XG5cbiAgICBzdGFjay5ub2RlLnNldENvbnRleHQoa2V5LCBbJ3VzLWVhc3QtMWEnLCAndXMtZWFzdC0xYiddKTtcblxuICAgIGNvbnN0IGF6cyA9IENvbnRleHQuZ2V0QXZhaWxhYmlsaXR5Wm9uZXMoc3RhY2spO1xuICAgIHRlc3QuZGVlcEVxdWFsKGF6cywgWyd1cy1lYXN0LTFhJywgJ3VzLWVhc3QtMWInXSk7XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnQXZhaWxhYmlsaXR5Wm9uZVByb3ZpZGVyIHdpbGwgY29tcGxhaW4gaWYgbm90IGdpdmVuIGEgbGlzdCcodGVzdDogVGVzdCkge1xuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKHVuZGVmaW5lZCwgJ1Rlc3RTdGFjaycsIHsgZW52OiB7IGFjY291bnQ6ICcxMjM0NScsIHJlZ2lvbjogJ3VzLWVhc3QtMScgfSB9KTtcbiAgICBjb25zdCBiZWZvcmUgPSBDb250ZXh0LmdldEF2YWlsYWJpbGl0eVpvbmVzKHN0YWNrKTtcbiAgICB0ZXN0LmRlZXBFcXVhbChiZWZvcmUsIFsgJ2R1bW15MWEnLCAnZHVtbXkxYicsICdkdW1teTFjJyBdKTtcbiAgICBjb25zdCBrZXkgPSBleHBlY3RlZENvbnRleHRLZXkoc3RhY2spO1xuXG4gICAgc3RhY2subm9kZS5zZXRDb250ZXh0KGtleSwgJ25vdC1hLWxpc3QnKTtcblxuICAgIHRlc3QudGhyb3dzKFxuICAgICAgKCkgPT4gQ29udGV4dC5nZXRBdmFpbGFiaWxpdHlab25lcyhzdGFjaylcbiAgICApO1xuXG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ0NvbnRleHRQcm92aWRlciBjb25zaXN0ZW50bHkgZ2VuZXJhdGVzIGEga2V5Jyh0ZXN0OiBUZXN0KSB7XG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2sodW5kZWZpbmVkLCAnVGVzdFN0YWNrJywgeyBlbnY6IHsgYWNjb3VudDogJzEyMzQ1JywgcmVnaW9uOiAndXMtZWFzdC0xJyB9IH0pO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IENvbnRleHRQcm92aWRlcihzdGFjaywgJ3NzbScsIHtcbiAgICAgIHBhcmFtZXRlck5hbWU6ICdmb28nLFxuICAgICAgYW55U3RyaW5nUGFyYW06ICdiYXInLFxuICAgIH0pO1xuICAgIGNvbnN0IGtleSA9IHByb3ZpZGVyLmtleTtcbiAgICB0ZXN0LmRlZXBFcXVhbChrZXksICdzc206YWNjb3VudD0xMjM0NTphbnlTdHJpbmdQYXJhbT1iYXI6cGFyYW1ldGVyTmFtZT1mb286cmVnaW9uPXVzLWVhc3QtMScpO1xuICAgIGNvbnN0IGNvbXBsZXggPSBuZXcgQ29udGV4dFByb3ZpZGVyKHN0YWNrLCAndnBjJywge1xuICAgICAgY2lkckJsb2NrOiAnMTkyLjE2OC4wLjE2JyxcbiAgICAgIHRhZ3M6IHsgTmFtZTogJ015VlBDJywgRW52OiAnUHJlcHJvZCcgfSxcbiAgICAgIGlndzogZmFsc2UsXG4gICAgfSk7XG4gICAgY29uc3QgY29tcGxleEtleSA9IGNvbXBsZXgua2V5O1xuICAgIHRlc3QuZGVlcEVxdWFsKGNvbXBsZXhLZXksXG4gICAgICAndnBjOmFjY291bnQ9MTIzNDU6Y2lkckJsb2NrPTE5Mi4xNjguMC4xNjppZ3c9ZmFsc2U6cmVnaW9uPXVzLWVhc3QtMTp0YWdzLkVudj1QcmVwcm9kOnRhZ3MuTmFtZT1NeVZQQycpO1xuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gICdLZXkgZ2VuZXJhdGlvbiBjYW4gY29udGFpbiBhcmJpdHJhcmlseSBkZWVwIHN0cnVjdHVyZXMnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKHVuZGVmaW5lZCwgJ1Rlc3RTdGFjaycsIHsgZW52OiB7IGFjY291bnQ6ICcxMjM0NScsIHJlZ2lvbjogJ3VzLWVhc3QtMScgfSB9KTtcblxuICAgIC8vIFdIRU5cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBDb250ZXh0UHJvdmlkZXIoc3RhY2ssICdwcm92aWRlcicsIHtcbiAgICAgIGxpc3Q6IFtcbiAgICAgICAgeyBrZXk6ICdrZXkxJywgdmFsdWU6ICd2YWx1ZTEnIH0sXG4gICAgICAgIHsga2V5OiAna2V5MicsIHZhbHVlOiAndmFsdWUyJyB9LFxuICAgICAgXSxcbiAgICB9KTtcblxuICAgIC8vIFRIRU5cbiAgICB0ZXN0LmVxdWFscyhwcm92aWRlci5rZXksICdwcm92aWRlcjphY2NvdW50PTEyMzQ1Omxpc3QuMC5rZXk9a2V5MTpsaXN0LjAudmFsdWU9dmFsdWUxOmxpc3QuMS5rZXk9a2V5MjpsaXN0LjEudmFsdWU9dmFsdWUyOnJlZ2lvbj11cy1lYXN0LTEnKTtcblxuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gICdTU00gcGFyYW1ldGVyIHByb3ZpZGVyIHdpbGwgcmV0dXJuIGNvbnRleHQgdmFsdWVzIGlmIGF2YWlsYWJsZScodGVzdDogVGVzdCkge1xuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKHVuZGVmaW5lZCwgJ1Rlc3RTdGFjaycsIHsgZW52OiB7IGFjY291bnQ6ICcxMjM0NScsIHJlZ2lvbjogJ3VzLWVhc3QtMScgfSB9KTtcbiAgICBDb250ZXh0LmdldFNzbVBhcmFtZXRlcihzdGFjaywgJ3Rlc3QnKTtcbiAgICBjb25zdCBrZXkgPSBleHBlY3RlZENvbnRleHRLZXkoc3RhY2spO1xuXG4gICAgc3RhY2subm9kZS5zZXRDb250ZXh0KGtleSwgJ2FiYycpO1xuXG4gICAgY29uc3Qgc3NtcCA9IENvbnRleHQuZ2V0U3NtUGFyYW1ldGVyKHN0YWNrLCAndGVzdCcpO1xuICAgIGNvbnN0IGF6cyA9IHN0YWNrLnJlc29sdmUoc3NtcCk7XG4gICAgdGVzdC5kZWVwRXF1YWwoYXpzLCAnYWJjJyk7XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnUmV0dXJuIGRlZmF1bHQgdmFsdWVzIGlmIFwiZW52XCIgaXMgdW5kZWZpbmVkIHRvIGZhY2lsaXRhdGUgdW5pdCB0ZXN0cywgYnV0IGFsc28gZXhwZWN0IG1ldGFkYXRhIHRvIGluY2x1ZGUgXCJlcnJvclwiIG1lc3NhZ2VzJyh0ZXN0OiBUZXN0KSB7XG4gICAgY29uc3QgYXBwID0gbmV3IEFwcCgpO1xuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKGFwcCwgJ3Rlc3Qtc3RhY2snKTtcblxuICAgIGNvbnN0IGNoaWxkID0gbmV3IENvbnN0cnVjdChzdGFjaywgJ0NoaWxkQ29uc3RydWN0Jyk7XG5cbiAgICB0ZXN0LmRlZXBFcXVhbChDb250ZXh0LmdldEF2YWlsYWJpbGl0eVpvbmVzKHN0YWNrKSwgWyAnZHVtbXkxYScsICdkdW1teTFiJywgJ2R1bW15MWMnIF0pO1xuICAgIHRlc3QuZGVlcEVxdWFsKENvbnRleHQuZ2V0U3NtUGFyYW1ldGVyKGNoaWxkLCAnZm9vJyksICdkdW1teScpO1xuXG4gICAgY29uc3QgYXNzZW1ibHkgPSBhcHAuc3ludGgoKTtcbiAgICBjb25zdCBvdXRwdXQgPSBhc3NlbWJseS5nZXRTdGFjaygndGVzdC1zdGFjaycpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gb3V0cHV0Lm1hbmlmZXN0Lm1ldGFkYXRhIHx8IHt9O1xuICAgIGNvbnN0IGF6RXJyb3I6IGN4YXBpLk1ldGFkYXRhRW50cnkgfCB1bmRlZmluZWQgPSBtZXRhZGF0YVsnL3Rlc3Qtc3RhY2snXS5maW5kKHggPT4geC50eXBlID09PSBjeGFwaS5FUlJPUl9NRVRBREFUQV9LRVkpO1xuICAgIGNvbnN0IHNzbUVycm9yOiBjeGFwaS5NZXRhZGF0YUVudHJ5IHwgdW5kZWZpbmVkID0gbWV0YWRhdGFbJy90ZXN0LXN0YWNrL0NoaWxkQ29uc3RydWN0J10uZmluZCh4ID0+IHgudHlwZSA9PT0gY3hhcGkuRVJST1JfTUVUQURBVEFfS0VZKTtcblxuICAgIHRlc3Qub2soYXpFcnJvciAmJiAoYXpFcnJvci5kYXRhIGFzIHN0cmluZykuaW5jbHVkZXMoJ0Nhbm5vdCBkZXRlcm1pbmUgc2NvcGUgZm9yIGNvbnRleHQgcHJvdmlkZXIgYXZhaWxhYmlsaXR5LXpvbmVzJykpO1xuICAgIHRlc3Qub2soc3NtRXJyb3IgJiYgKHNzbUVycm9yLmRhdGEgYXMgc3RyaW5nKS5pbmNsdWRlcygnQ2Fubm90IGRldGVybWluZSBzY29wZSBmb3IgY29udGV4dCBwcm92aWRlciBzc20nKSk7XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnZmFpbHMgaWYgcmVnaW9uIGlzIG5vdCBzcGVjaWZpZWQgaW4gQ0xJIGNvbnRleHQnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG5cbiAgICAvLyBXSEVOXG4gICAgc3RhY2subm9kZS5zZXRDb250ZXh0KGN4YXBpLkRFRkFVTFRfQUNDT1VOVF9DT05URVhUX0tFWSwgJzExMTExMTExMTEnKTtcblxuICAgIC8vIFRIRU5cbiAgICB0ZXN0LnRocm93cygoKSA9PiBDb250ZXh0LmdldEF2YWlsYWJpbGl0eVpvbmVzKHN0YWNrKSwgL0EgcmVnaW9uIG11c3QgYmUgc3BlY2lmaWVkIGluIG9yZGVyIHRvIG9idGFpbiBlbnZpcm9ubWVudGFsIGNvbnRleHQ6IGF2YWlsYWJpbGl0eS16b25lcy8pO1xuICAgIHRlc3QuZG9uZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZXhwZWN0ZWQgY29udGV4dCBrZXkgZnJvbSBhIHN0YWNrIHdpdGggbWlzc2luZyBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIGV4cGVjdGVkQ29udGV4dEtleShzdGFjazogU3RhY2spOiBzdHJpbmcge1xuICBjb25zdCBtaXNzaW5nID0gQ29uc3RydWN0Tm9kZS5zeW50aChzdGFjay5ub2RlKS5tYW5pZmVzdC5taXNzaW5nO1xuICBpZiAoIW1pc3NpbmcgfHwgbWlzc2luZy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGluZyBhc3NlbWJseSB0byBpbmNsdWRlIGEgc2luZ2xlIG1pc3NpbmcgY29udGV4dCByZXBvcnRgKTtcbiAgfVxuICByZXR1cm4gbWlzc2luZ1swXS5rZXk7XG59XG4iXX0=