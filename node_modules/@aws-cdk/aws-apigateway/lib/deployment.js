"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cdk_1 = require("@aws-cdk/cdk");
const crypto = require("crypto");
const apigateway_generated_1 = require("./apigateway.generated");
/**
 * A Deployment of a REST API.
 *
 * An immutable representation of a RestApi resource that can be called by users
 * using Stages. A deployment must be associated with a Stage for it to be
 * callable over the Internet.
 *
 * Normally, you don't need to define deployments manually. The RestApi
 * construct manages a Deployment resource that represents the latest model. It
 * can be accessed through `restApi.latestDeployment` (unless `deploy: false` is
 * set when defining the `RestApi`).
 *
 * If you manually define this resource, you will need to know that since
 * deployments are immutable, as long as the resource's logical ID doesn't
 * change, the deployment will represent the snapshot in time in which the
 * resource was created. This means that if you modify the RestApi model (i.e.
 * add methods or resources), these changes will not be reflected unless a new
 * deployment resource is created.
 *
 * To achieve this behavior, the method `addToLogicalId(data)` can be used to
 * augment the logical ID generated for the deployment resource such that it
 * will include arbitrary data. This is done automatically for the
 * `restApi.latestDeployment` deployment.
 *
 * Furthermore, since a deployment does not reference any of the REST API
 * resources and methods, CloudFormation will likely provision it before these
 * resources are created, which means that it will represent a "half-baked"
 * model. Use the `node.addDependency(dep)` method to circumvent that. This is done
 * automatically for the `restApi.latestDeployment` deployment.
 */
class Deployment extends cdk_1.Resource {
    constructor(scope, id, props) {
        super(scope, id);
        this.resource = new LatestDeploymentResource(this, 'Resource', {
            description: props.description,
            restApiId: props.api.restApiId,
        });
        if (props.retainDeployments) {
            this.resource.options.deletionPolicy = cdk_1.DeletionPolicy.Retain;
        }
        this.api = props.api;
        this.deploymentId = cdk_1.Lazy.stringValue({ produce: () => this.resource.refAsString });
    }
    /**
     * Adds a component to the hash that determines this Deployment resource's
     * logical ID.
     *
     * This should be called by constructs of the API Gateway model that want to
     * invalidate the deployment when their settings change. The component will
     * be resolve()ed during synthesis so tokens are welcome.
     */
    addToLogicalId(data) {
        this.resource.addToLogicalId(data);
    }
}
exports.Deployment = Deployment;
class LatestDeploymentResource extends apigateway_generated_1.CfnDeployment {
    constructor(scope, id, props) {
        super(scope, id, props);
        this.hashComponents = new Array();
        this.originalLogicalId = cdk_1.Stack.of(this).getLogicalId(this);
    }
    /**
     * Allows adding arbitrary data to the hashed logical ID of this deployment.
     * This can be used to couple the deployment to the API Gateway model.
     */
    addToLogicalId(data) {
        // if the construct is locked, it means we are already synthesizing and then
        // we can't modify the hash because we might have already calculated it.
        if (this.node.locked) {
            throw new Error('Cannot modify the logical ID when the construct is locked');
        }
        this.hashComponents.push(data);
    }
    /**
     * Hooks into synthesis to calculate a logical ID that hashes all the components
     * add via `addToLogicalId`.
     */
    prepare() {
        const stack = cdk_1.Stack.of(this);
        // if hash components were added to the deployment, we use them to calculate
        // a logical ID for the deployment resource.
        if (this.hashComponents.length > 0) {
            const md5 = crypto.createHash('md5');
            this.hashComponents
                .map(c => stack.resolve(c))
                .forEach(c => md5.update(JSON.stringify(c)));
            this.overrideLogicalId(this.originalLogicalId + md5.digest("hex"));
        }
        super.prepare();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwbG95bWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlcGxveW1lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxzQ0FBZ0Y7QUFDaEYsaUNBQWtDO0FBQ2xDLGlFQUEyRTtBQTBCM0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJHO0FBQ0gsTUFBYSxVQUFXLFNBQVEsY0FBUTtJQU90QyxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLEtBQXNCO1FBQzlELEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFakIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLHdCQUF3QixDQUFDLElBQUksRUFBRSxVQUFVLEVBQUU7WUFDN0QsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXO1lBQzlCLFNBQVMsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLFNBQVM7U0FDL0IsQ0FBQyxDQUFDO1FBRUgsSUFBSSxLQUFLLENBQUMsaUJBQWlCLEVBQUU7WUFDM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsY0FBYyxHQUFHLG9CQUFjLENBQUMsTUFBTSxDQUFDO1NBQzlEO1FBRUQsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxZQUFZLEdBQUcsVUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7SUFDckYsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxjQUFjLENBQUMsSUFBUztRQUM3QixJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNyQyxDQUFDO0NBQ0Y7QUFsQ0QsZ0NBa0NDO0FBRUQsTUFBTSx3QkFBeUIsU0FBUSxvQ0FBYTtJQUlsRCxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLEtBQXlCO1FBQ2pFLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBSmxCLG1CQUFjLEdBQUcsSUFBSSxLQUFLLEVBQU8sQ0FBQztRQU14QyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsV0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUVEOzs7T0FHRztJQUNJLGNBQWMsQ0FBQyxJQUFhO1FBQ2pDLDRFQUE0RTtRQUM1RSx3RUFBd0U7UUFDeEUsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNwQixNQUFNLElBQUksS0FBSyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7U0FDOUU7UUFFRCxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ08sT0FBTztRQUNmLE1BQU0sS0FBSyxHQUFHLFdBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFN0IsNEVBQTRFO1FBQzVFLDRDQUE0QztRQUM1QyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNsQyxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JDLElBQUksQ0FBQyxjQUFjO2lCQUNoQixHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUMxQixPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRS9DLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQ3BFO1FBRUQsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2xCLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0cnVjdCwgRGVsZXRpb25Qb2xpY3ksIExhenksIFJlc291cmNlLCBTdGFjayB9IGZyb20gJ0Bhd3MtY2RrL2Nkayc7XG5pbXBvcnQgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5pbXBvcnQgeyBDZm5EZXBsb3ltZW50LCBDZm5EZXBsb3ltZW50UHJvcHMgfSBmcm9tICcuL2FwaWdhdGV3YXkuZ2VuZXJhdGVkJztcbmltcG9ydCB7IElSZXN0QXBpIH0gZnJvbSAnLi9yZXN0YXBpJztcblxuZXhwb3J0IGludGVyZmFjZSBEZXBsb3ltZW50UHJvcHMgIHtcbiAgLyoqXG4gICAqIFRoZSBSZXN0IEFQSSB0byBkZXBsb3kuXG4gICAqL1xuICByZWFkb25seSBhcGk6IElSZXN0QXBpO1xuXG4gIC8qKlxuICAgKiBBIGRlc2NyaXB0aW9uIG9mIHRoZSBwdXJwb3NlIG9mIHRoZSBBUEkgR2F0ZXdheSBkZXBsb3ltZW50LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZW4gYW4gQVBJIEdhdGV3YXkgbW9kZWwgaXMgdXBkYXRlZCwgYSBuZXcgZGVwbG95bWVudCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgY3JlYXRlZC5cbiAgICogSWYgdGhpcyBpcyB0cnVlIChkZWZhdWx0KSwgdGhlIG9sZCBBUEkgR2F0ZXdheSBEZXBsb3ltZW50IHJlc291cmNlIHdpbGwgbm90IGJlIGRlbGV0ZWQuXG4gICAqIFRoaXMgd2lsbCBhbGxvdyBtYW51YWxseSByZXZlcnRpbmcgYmFjayB0byBhIHByZXZpb3VzIGRlcGxveW1lbnQgaW4gY2FzZSBmb3IgZXhhbXBsZVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgcmV0YWluRGVwbG95bWVudHM/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEEgRGVwbG95bWVudCBvZiBhIFJFU1QgQVBJLlxuICpcbiAqIEFuIGltbXV0YWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIFJlc3RBcGkgcmVzb3VyY2UgdGhhdCBjYW4gYmUgY2FsbGVkIGJ5IHVzZXJzXG4gKiB1c2luZyBTdGFnZXMuIEEgZGVwbG95bWVudCBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBhIFN0YWdlIGZvciBpdCB0byBiZVxuICogY2FsbGFibGUgb3ZlciB0aGUgSW50ZXJuZXQuXG4gKlxuICogTm9ybWFsbHksIHlvdSBkb24ndCBuZWVkIHRvIGRlZmluZSBkZXBsb3ltZW50cyBtYW51YWxseS4gVGhlIFJlc3RBcGlcbiAqIGNvbnN0cnVjdCBtYW5hZ2VzIGEgRGVwbG95bWVudCByZXNvdXJjZSB0aGF0IHJlcHJlc2VudHMgdGhlIGxhdGVzdCBtb2RlbC4gSXRcbiAqIGNhbiBiZSBhY2Nlc3NlZCB0aHJvdWdoIGByZXN0QXBpLmxhdGVzdERlcGxveW1lbnRgICh1bmxlc3MgYGRlcGxveTogZmFsc2VgIGlzXG4gKiBzZXQgd2hlbiBkZWZpbmluZyB0aGUgYFJlc3RBcGlgKS5cbiAqXG4gKiBJZiB5b3UgbWFudWFsbHkgZGVmaW5lIHRoaXMgcmVzb3VyY2UsIHlvdSB3aWxsIG5lZWQgdG8ga25vdyB0aGF0IHNpbmNlXG4gKiBkZXBsb3ltZW50cyBhcmUgaW1tdXRhYmxlLCBhcyBsb25nIGFzIHRoZSByZXNvdXJjZSdzIGxvZ2ljYWwgSUQgZG9lc24ndFxuICogY2hhbmdlLCB0aGUgZGVwbG95bWVudCB3aWxsIHJlcHJlc2VudCB0aGUgc25hcHNob3QgaW4gdGltZSBpbiB3aGljaCB0aGVcbiAqIHJlc291cmNlIHdhcyBjcmVhdGVkLiBUaGlzIG1lYW5zIHRoYXQgaWYgeW91IG1vZGlmeSB0aGUgUmVzdEFwaSBtb2RlbCAoaS5lLlxuICogYWRkIG1ldGhvZHMgb3IgcmVzb3VyY2VzKSwgdGhlc2UgY2hhbmdlcyB3aWxsIG5vdCBiZSByZWZsZWN0ZWQgdW5sZXNzIGEgbmV3XG4gKiBkZXBsb3ltZW50IHJlc291cmNlIGlzIGNyZWF0ZWQuXG4gKlxuICogVG8gYWNoaWV2ZSB0aGlzIGJlaGF2aW9yLCB0aGUgbWV0aG9kIGBhZGRUb0xvZ2ljYWxJZChkYXRhKWAgY2FuIGJlIHVzZWQgdG9cbiAqIGF1Z21lbnQgdGhlIGxvZ2ljYWwgSUQgZ2VuZXJhdGVkIGZvciB0aGUgZGVwbG95bWVudCByZXNvdXJjZSBzdWNoIHRoYXQgaXRcbiAqIHdpbGwgaW5jbHVkZSBhcmJpdHJhcnkgZGF0YS4gVGhpcyBpcyBkb25lIGF1dG9tYXRpY2FsbHkgZm9yIHRoZVxuICogYHJlc3RBcGkubGF0ZXN0RGVwbG95bWVudGAgZGVwbG95bWVudC5cbiAqXG4gKiBGdXJ0aGVybW9yZSwgc2luY2UgYSBkZXBsb3ltZW50IGRvZXMgbm90IHJlZmVyZW5jZSBhbnkgb2YgdGhlIFJFU1QgQVBJXG4gKiByZXNvdXJjZXMgYW5kIG1ldGhvZHMsIENsb3VkRm9ybWF0aW9uIHdpbGwgbGlrZWx5IHByb3Zpc2lvbiBpdCBiZWZvcmUgdGhlc2VcbiAqIHJlc291cmNlcyBhcmUgY3JlYXRlZCwgd2hpY2ggbWVhbnMgdGhhdCBpdCB3aWxsIHJlcHJlc2VudCBhIFwiaGFsZi1iYWtlZFwiXG4gKiBtb2RlbC4gVXNlIHRoZSBgbm9kZS5hZGREZXBlbmRlbmN5KGRlcClgIG1ldGhvZCB0byBjaXJjdW12ZW50IHRoYXQuIFRoaXMgaXMgZG9uZVxuICogYXV0b21hdGljYWxseSBmb3IgdGhlIGByZXN0QXBpLmxhdGVzdERlcGxveW1lbnRgIGRlcGxveW1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXBsb3ltZW50IGV4dGVuZHMgUmVzb3VyY2Uge1xuICAvKiogQGF0dHJpYnV0ZSAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZGVwbG95bWVudElkOiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBhcGk6IElSZXN0QXBpO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgcmVzb3VyY2U6IExhdGVzdERlcGxveW1lbnRSZXNvdXJjZTtcblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogRGVwbG95bWVudFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIHRoaXMucmVzb3VyY2UgPSBuZXcgTGF0ZXN0RGVwbG95bWVudFJlc291cmNlKHRoaXMsICdSZXNvdXJjZScsIHtcbiAgICAgIGRlc2NyaXB0aW9uOiBwcm9wcy5kZXNjcmlwdGlvbixcbiAgICAgIHJlc3RBcGlJZDogcHJvcHMuYXBpLnJlc3RBcGlJZCxcbiAgICB9KTtcblxuICAgIGlmIChwcm9wcy5yZXRhaW5EZXBsb3ltZW50cykge1xuICAgICAgdGhpcy5yZXNvdXJjZS5vcHRpb25zLmRlbGV0aW9uUG9saWN5ID0gRGVsZXRpb25Qb2xpY3kuUmV0YWluO1xuICAgIH1cblxuICAgIHRoaXMuYXBpID0gcHJvcHMuYXBpO1xuICAgIHRoaXMuZGVwbG95bWVudElkID0gTGF6eS5zdHJpbmdWYWx1ZSh7IHByb2R1Y2U6ICgpID0+IHRoaXMucmVzb3VyY2UucmVmQXNTdHJpbmcgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNvbXBvbmVudCB0byB0aGUgaGFzaCB0aGF0IGRldGVybWluZXMgdGhpcyBEZXBsb3ltZW50IHJlc291cmNlJ3NcbiAgICogbG9naWNhbCBJRC5cbiAgICpcbiAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJ5IGNvbnN0cnVjdHMgb2YgdGhlIEFQSSBHYXRld2F5IG1vZGVsIHRoYXQgd2FudCB0b1xuICAgKiBpbnZhbGlkYXRlIHRoZSBkZXBsb3ltZW50IHdoZW4gdGhlaXIgc2V0dGluZ3MgY2hhbmdlLiBUaGUgY29tcG9uZW50IHdpbGxcbiAgICogYmUgcmVzb2x2ZSgpZWQgZHVyaW5nIHN5bnRoZXNpcyBzbyB0b2tlbnMgYXJlIHdlbGNvbWUuXG4gICAqL1xuICBwdWJsaWMgYWRkVG9Mb2dpY2FsSWQoZGF0YTogYW55KSB7XG4gICAgdGhpcy5yZXNvdXJjZS5hZGRUb0xvZ2ljYWxJZChkYXRhKTtcbiAgfVxufVxuXG5jbGFzcyBMYXRlc3REZXBsb3ltZW50UmVzb3VyY2UgZXh0ZW5kcyBDZm5EZXBsb3ltZW50IHtcbiAgcHJpdmF0ZSBoYXNoQ29tcG9uZW50cyA9IG5ldyBBcnJheTxhbnk+KCk7XG4gIHByaXZhdGUgb3JpZ2luYWxMb2dpY2FsSWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogQ2ZuRGVwbG95bWVudFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCBwcm9wcyk7XG5cbiAgICB0aGlzLm9yaWdpbmFsTG9naWNhbElkID0gU3RhY2sub2YodGhpcykuZ2V0TG9naWNhbElkKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBhZGRpbmcgYXJiaXRyYXJ5IGRhdGEgdG8gdGhlIGhhc2hlZCBsb2dpY2FsIElEIG9mIHRoaXMgZGVwbG95bWVudC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBjb3VwbGUgdGhlIGRlcGxveW1lbnQgdG8gdGhlIEFQSSBHYXRld2F5IG1vZGVsLlxuICAgKi9cbiAgcHVibGljIGFkZFRvTG9naWNhbElkKGRhdGE6IHVua25vd24pIHtcbiAgICAvLyBpZiB0aGUgY29uc3RydWN0IGlzIGxvY2tlZCwgaXQgbWVhbnMgd2UgYXJlIGFscmVhZHkgc3ludGhlc2l6aW5nIGFuZCB0aGVuXG4gICAgLy8gd2UgY2FuJ3QgbW9kaWZ5IHRoZSBoYXNoIGJlY2F1c2Ugd2UgbWlnaHQgaGF2ZSBhbHJlYWR5IGNhbGN1bGF0ZWQgaXQuXG4gICAgaWYgKHRoaXMubm9kZS5sb2NrZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1vZGlmeSB0aGUgbG9naWNhbCBJRCB3aGVuIHRoZSBjb25zdHJ1Y3QgaXMgbG9ja2VkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5oYXNoQ29tcG9uZW50cy5wdXNoKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhvb2tzIGludG8gc3ludGhlc2lzIHRvIGNhbGN1bGF0ZSBhIGxvZ2ljYWwgSUQgdGhhdCBoYXNoZXMgYWxsIHRoZSBjb21wb25lbnRzXG4gICAqIGFkZCB2aWEgYGFkZFRvTG9naWNhbElkYC5cbiAgICovXG4gIHByb3RlY3RlZCBwcmVwYXJlKCkge1xuICAgIGNvbnN0IHN0YWNrID0gU3RhY2sub2YodGhpcyk7XG5cbiAgICAvLyBpZiBoYXNoIGNvbXBvbmVudHMgd2VyZSBhZGRlZCB0byB0aGUgZGVwbG95bWVudCwgd2UgdXNlIHRoZW0gdG8gY2FsY3VsYXRlXG4gICAgLy8gYSBsb2dpY2FsIElEIGZvciB0aGUgZGVwbG95bWVudCByZXNvdXJjZS5cbiAgICBpZiAodGhpcy5oYXNoQ29tcG9uZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBtZDUgPSBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1Jyk7XG4gICAgICB0aGlzLmhhc2hDb21wb25lbnRzXG4gICAgICAgIC5tYXAoYyA9PiBzdGFjay5yZXNvbHZlKGMpKVxuICAgICAgICAuZm9yRWFjaChjID0+IG1kNS51cGRhdGUoSlNPTi5zdHJpbmdpZnkoYykpKTtcblxuICAgICAgdGhpcy5vdmVycmlkZUxvZ2ljYWxJZCh0aGlzLm9yaWdpbmFsTG9naWNhbElkICsgbWQ1LmRpZ2VzdChcImhleFwiKSk7XG4gICAgfVxuXG4gICAgc3VwZXIucHJlcGFyZSgpO1xuICB9XG59XG4iXX0=