"use strict";
const assert_1 = require("@aws-cdk/assert");
const cdk_1 = require("@aws-cdk/cdk");
const lib_1 = require("../lib");
module.exports = {
    'security group can allows all outbound traffic by default'(test) {
        // GIVEN
        const stack = new cdk_1.Stack();
        const vpc = new lib_1.Vpc(stack, 'VPC');
        // WHEN
        new lib_1.SecurityGroup(stack, 'SG1', { vpc, allowAllOutbound: true });
        // THEN
        assert_1.expect(stack).to(assert_1.haveResource('AWS::EC2::SecurityGroup', {
            SecurityGroupEgress: [
                {
                    CidrIp: "0.0.0.0/0",
                    Description: "Allow all outbound traffic by default",
                    IpProtocol: "-1"
                }
            ],
        }));
        test.done();
    },
    'no new outbound rule is added if we are allowing all traffic anyway'(test) {
        // GIVEN
        const stack = new cdk_1.Stack();
        const vpc = new lib_1.Vpc(stack, 'VPC');
        // WHEN
        const sg = new lib_1.SecurityGroup(stack, 'SG1', { vpc, allowAllOutbound: true });
        sg.addEgressRule(new lib_1.AnyIPv4(), new lib_1.TcpPort(86), 'This does not show up');
        // THEN
        assert_1.expect(stack).to(assert_1.haveResource('AWS::EC2::SecurityGroup', {
            SecurityGroupEgress: [
                {
                    CidrIp: "0.0.0.0/0",
                    Description: "Allow all outbound traffic by default",
                    IpProtocol: "-1"
                },
            ],
        }));
        test.done();
    },
    'security group disallow outbound traffic by default'(test) {
        // GIVEN
        const stack = new cdk_1.Stack();
        const vpc = new lib_1.Vpc(stack, 'VPC');
        // WHEN
        new lib_1.SecurityGroup(stack, 'SG1', { vpc, allowAllOutbound: false });
        // THEN
        assert_1.expect(stack).to(assert_1.haveResource('AWS::EC2::SecurityGroup', {
            SecurityGroupEgress: [
                {
                    CidrIp: "255.255.255.255/32",
                    Description: "Disallow all traffic",
                    FromPort: 252,
                    IpProtocol: "icmp",
                    ToPort: 86
                }
            ],
        }));
        test.done();
    },
    'bogus outbound rule disappears if another rule is added'(test) {
        // GIVEN
        const stack = new cdk_1.Stack();
        const vpc = new lib_1.Vpc(stack, 'VPC');
        // WHEN
        const sg = new lib_1.SecurityGroup(stack, 'SG1', { vpc, allowAllOutbound: false });
        sg.addEgressRule(new lib_1.AnyIPv4(), new lib_1.TcpPort(86), 'This replaces the other one');
        // THEN
        assert_1.expect(stack).to(assert_1.haveResource('AWS::EC2::SecurityGroup', {
            SecurityGroupEgress: [
                {
                    CidrIp: "0.0.0.0/0",
                    Description: "This replaces the other one",
                    FromPort: 86,
                    IpProtocol: "tcp",
                    ToPort: 86
                }
            ],
        }));
        test.done();
    },
    'all outbound rule cannot be added after creation'(test) {
        // GIVEN
        const stack = new cdk_1.Stack();
        const vpc = new lib_1.Vpc(stack, 'VPC');
        // WHEN
        const sg = new lib_1.SecurityGroup(stack, 'SG1', { vpc, allowAllOutbound: false });
        test.throws(() => {
            sg.addEgressRule(new lib_1.AnyIPv4(), new lib_1.AllTraffic(), 'All traffic');
        }, /Cannot add/);
        test.done();
    },
    'peer between all types of peers and port range types'(test) {
        // GIVEN
        const stack = new cdk_1.Stack(undefined, 'TestStack', { env: { account: '12345678', region: 'dummy' } });
        const vpc = new lib_1.Vpc(stack, 'VPC');
        const sg = new lib_1.SecurityGroup(stack, 'SG', { vpc });
        const peers = [
            new lib_1.SecurityGroup(stack, 'PeerGroup', { vpc }),
            new lib_1.AnyIPv4(),
            new lib_1.AnyIPv6(),
            new lib_1.PrefixList('pl-012345'),
        ];
        const ports = [
            new lib_1.TcpPort(1234),
            new lib_1.TcpPort(cdk_1.Lazy.numberValue({ produce: () => 5000 })),
            new lib_1.TcpAllPorts(),
            new lib_1.TcpPortRange(80, 90),
            new lib_1.UdpPort(2345),
            new lib_1.UdpPort(cdk_1.Lazy.numberValue({ produce: () => 7777 })),
            new lib_1.UdpAllPorts(),
            new lib_1.UdpPortRange(85, 95),
            new lib_1.IcmpTypeAndCode(5, 1),
            new lib_1.IcmpAllTypeCodes(8),
            new lib_1.IcmpAllTypesAndCodes(),
            new lib_1.IcmpPing(),
            new lib_1.AllTraffic()
        ];
        // WHEN
        for (const peer of peers) {
            for (const port of ports) {
                sg.connections.allowTo(peer, port);
                sg.connections.allowFrom(peer, port);
            }
        }
        // THEN -- no crash
        test.done();
    },
    'if tokens are used in ports, `canInlineRule` should be false to avoid cycles'(test) {
        // GIVEN
        const p1 = cdk_1.Lazy.numberValue({ produce: () => 80 });
        const p2 = cdk_1.Lazy.numberValue({ produce: () => 5000 });
        // WHEN
        const ports = [
            new lib_1.TcpPort(p1),
            new lib_1.TcpPort(p2),
            new lib_1.TcpPortRange(p1, 90),
            new lib_1.TcpPortRange(80, p2),
            new lib_1.TcpPortRange(p1, p2),
            new lib_1.UdpPort(p1),
            new lib_1.UdpPortRange(p1, 95),
            new lib_1.UdpPortRange(85, p2),
            new lib_1.UdpPortRange(p1, p2),
            new lib_1.IcmpTypeAndCode(p1, 1),
            new lib_1.IcmpTypeAndCode(5, p1),
            new lib_1.IcmpTypeAndCode(p1, p2),
            new lib_1.IcmpAllTypeCodes(p1),
        ];
        // THEN
        for (const range of ports) {
            test.equal(range.canInlineRule, false, range.toString());
        }
        test.done();
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5zZWN1cml0eS1ncm91cC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRlc3Quc2VjdXJpdHktZ3JvdXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLDRDQUF1RDtBQUN2RCxzQ0FBMkM7QUFHM0MsZ0NBaUJnQjtBQUVoQixpQkFBUztJQUNQLDJEQUEyRCxDQUFDLElBQVU7UUFDcEUsUUFBUTtRQUNSLE1BQU0sS0FBSyxHQUFHLElBQUksV0FBSyxFQUFFLENBQUM7UUFDMUIsTUFBTSxHQUFHLEdBQUcsSUFBSSxTQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRWxDLE9BQU87UUFDUCxJQUFJLG1CQUFhLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFLEdBQUcsRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRWpFLE9BQU87UUFDUCxlQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLHFCQUFZLENBQUMseUJBQXlCLEVBQUU7WUFDdkQsbUJBQW1CLEVBQUU7Z0JBQ25CO29CQUNFLE1BQU0sRUFBRSxXQUFXO29CQUNuQixXQUFXLEVBQUUsdUNBQXVDO29CQUNwRCxVQUFVLEVBQUUsSUFBSTtpQkFDakI7YUFDRjtTQUNGLENBQUMsQ0FBQyxDQUFDO1FBRUosSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2QsQ0FBQztJQUVELHFFQUFxRSxDQUFDLElBQVU7UUFDOUUsUUFBUTtRQUNSLE1BQU0sS0FBSyxHQUFHLElBQUksV0FBSyxFQUFFLENBQUM7UUFDMUIsTUFBTSxHQUFHLEdBQUcsSUFBSSxTQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRWxDLE9BQU87UUFDUCxNQUFNLEVBQUUsR0FBRyxJQUFJLG1CQUFhLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFLEdBQUcsRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQzVFLEVB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QUUsQ0FBQztZQUN4QixJQUFJLGFBQU8sQ0FBQyxFQUFFLENBQUM7WUFDZixJQUFJLGtCQUFZLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQztZQUN4QixJQUFJLGtCQUFZLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQztZQUN4QixJQUFJLGtCQUFZLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQztZQUN4QixJQUFJLHFCQUFlLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUMxQixJQUFJLHFCQUFlLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUMxQixJQUFJLHFCQUFlLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQztZQUMzQixJQUFJLHNCQUFnQixDQUFDLEVBQUUsQ0FBQztTQUN6QixDQUFDO1FBRUYsT0FBTztRQUNQLEtBQUssTUFBTSxLQUFLLElBQUksS0FBSyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDMUQ7UUFFRCxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDZCxDQUFDO0NBQ0YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4cGVjdCwgaGF2ZVJlc291cmNlIH0gZnJvbSAnQGF3cy1jZGsvYXNzZXJ0JztcbmltcG9ydCB7IExhenksIFN0YWNrIH0gZnJvbSAnQGF3cy1jZGsvY2RrJztcbmltcG9ydCB7IFRlc3QgfSBmcm9tICdub2RldW5pdCc7XG5cbmltcG9ydCB7XG4gIEFsbFRyYWZmaWMsXG4gIEFueUlQdjQsXG4gIEFueUlQdjYsXG4gIEljbXBBbGxUeXBlQ29kZXMsXG4gIEljbXBBbGxUeXBlc0FuZENvZGVzLFxuICBJY21wUGluZyxcbiAgSWNtcFR5cGVBbmRDb2RlLFxuICBQcmVmaXhMaXN0LFxuICBTZWN1cml0eUdyb3VwLFxuICBUY3BBbGxQb3J0cyxcbiAgVGNwUG9ydCxcbiAgVGNwUG9ydFJhbmdlLFxuICBVZHBBbGxQb3J0cyxcbiAgVWRwUG9ydCxcbiAgVWRwUG9ydFJhbmdlLFxuICBWcGNcbn0gZnJvbSBcIi4uL2xpYlwiO1xuXG5leHBvcnQgPSB7XG4gICdzZWN1cml0eSBncm91cCBjYW4gYWxsb3dzIGFsbCBvdXRib3VuZCB0cmFmZmljIGJ5IGRlZmF1bHQnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgY29uc3QgdnBjID0gbmV3IFZwYyhzdGFjaywgJ1ZQQycpO1xuXG4gICAgLy8gV0hFTlxuICAgIG5ldyBTZWN1cml0eUdyb3VwKHN0YWNrLCAnU0cxJywgeyB2cGMsIGFsbG93QWxsT3V0Ym91bmQ6IHRydWUgfSk7XG5cbiAgICAvLyBUSEVOXG4gICAgZXhwZWN0KHN0YWNrKS50byhoYXZlUmVzb3VyY2UoJ0FXUzo6RUMyOjpTZWN1cml0eUdyb3VwJywge1xuICAgICAgU2VjdXJpdHlHcm91cEVncmVzczogW1xuICAgICAgICB7XG4gICAgICAgICAgQ2lkcklwOiBcIjAuMC4wLjAvMFwiLFxuICAgICAgICAgIERlc2NyaXB0aW9uOiBcIkFsbG93IGFsbCBvdXRib3VuZCB0cmFmZmljIGJ5IGRlZmF1bHRcIixcbiAgICAgICAgICBJcFByb3RvY29sOiBcIi0xXCJcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICB9KSk7XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnbm8gbmV3IG91dGJvdW5kIHJ1bGUgaXMgYWRkZWQgaWYgd2UgYXJlIGFsbG93aW5nIGFsbCB0cmFmZmljIGFueXdheScodGVzdDogVGVzdCkge1xuICAgIC8vIEdJVkVOXG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICBjb25zdCB2cGMgPSBuZXcgVnBjKHN0YWNrLCAnVlBDJyk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29uc3Qgc2cgPSBuZXcgU2VjdXJpdHlHcm91cChzdGFjaywgJ1NHMScsIHsgdnBjLCBhbGxvd0FsbE91dGJvdW5kOiB0cnVlIH0pO1xuICAgIHNnLmFkZEVncmVzc1J1bGUobmV3IEFueUlQdjQoKSwgbmV3IFRjcFBvcnQoODYpLCAnVGhpcyBkb2VzIG5vdCBzaG93IHVwJyk7XG5cbiAgICAvLyBUSEVOXG4gICAgZXhwZWN0KHN0YWNrKS50byhoYXZlUmVzb3VyY2UoJ0FXUzo6RUMyOjpTZWN1cml0eUdyb3VwJywge1xuICAgICAgU2VjdXJpdHlHcm91cEVncmVzczogW1xuICAgICAgICB7XG4gICAgICAgICAgQ2lkcklwOiBcIjAuMC4wLjAvMFwiLFxuICAgICAgICAgIERlc2NyaXB0aW9uOiBcIkFsbG93IGFsbCBvdXRib3VuZCB0cmFmZmljIGJ5IGRlZmF1bHRcIixcbiAgICAgICAgICBJcFByb3RvY29sOiBcIi0xXCJcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSkpO1xuXG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ3NlY3VyaXR5IGdyb3VwIGRpc2FsbG93IG91dGJvdW5kIHRyYWZmaWMgYnkgZGVmYXVsdCcodGVzdDogVGVzdCkge1xuICAgIC8vIEdJVkVOXG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICBjb25zdCB2cGMgPSBuZXcgVnBjKHN0YWNrLCAnVlBDJyk7XG5cbiAgICAvLyBXSEVOXG4gICAgbmV3IFNlY3VyaXR5R3JvdXAoc3RhY2ssICdTRzEnLCB7IHZwYywgYWxsb3dBbGxPdXRib3VuZDogZmFsc2UgfSk7XG5cbiAgICAvLyBUSEVOXG4gICAgZXhwZWN0KHN0YWNrKS50byhoYXZlUmVzb3VyY2UoJ0FXUzo6RUMyOjpTZWN1cml0eUdyb3VwJywge1xuICAgICAgU2VjdXJpdHlHcm91cEVncmVzczogW1xuICAgICAgICB7XG4gICAgICAgICAgQ2lkcklwOiBcIjI1NS4yNTUuMjU1LjI1NS8zMlwiLFxuICAgICAgICAgIERlc2NyaXB0aW9uOiBcIkRpc2FsbG93IGFsbCB0cmFmZmljXCIsXG4gICAgICAgICAgRnJvbVBvcnQ6IDI1MixcbiAgICAgICAgICBJcFByb3RvY29sOiBcImljbXBcIixcbiAgICAgICAgICBUb1BvcnQ6IDg2XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgfSkpO1xuXG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ2JvZ3VzIG91dGJvdW5kIHJ1bGUgZGlzYXBwZWFycyBpZiBhbm90aGVyIHJ1bGUgaXMgYWRkZWQnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgY29uc3QgdnBjID0gbmV3IFZwYyhzdGFjaywgJ1ZQQycpO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IHNnID0gbmV3IFNlY3VyaXR5R3JvdXAoc3RhY2ssICdTRzEnLCB7IHZwYywgYWxsb3dBbGxPdXRib3VuZDogZmFsc2UgfSk7XG4gICAgc2cuYWRkRWdyZXNzUnVsZShuZXcgQW55SVB2NCgpLCBuZXcgVGNwUG9ydCg4NiksICdUaGlzIHJlcGxhY2VzIHRoZSBvdGhlciBvbmUnKTtcblxuICAgIC8vIFRIRU5cbiAgICBleHBlY3Qoc3RhY2spLnRvKGhhdmVSZXNvdXJjZSgnQVdTOjpFQzI6OlNlY3VyaXR5R3JvdXAnLCB7XG4gICAgICBTZWN1cml0eUdyb3VwRWdyZXNzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBDaWRySXA6IFwiMC4wLjAuMC8wXCIsXG4gICAgICAgICAgRGVzY3JpcHRpb246IFwiVGhpcyByZXBsYWNlcyB0aGUgb3RoZXIgb25lXCIsXG4gICAgICAgICAgRnJvbVBvcnQ6IDg2LFxuICAgICAgICAgIElwUHJvdG9jb2w6IFwidGNwXCIsXG4gICAgICAgICAgVG9Qb3J0OiA4NlxuICAgICAgICB9XG4gICAgICBdLFxuICAgIH0pKTtcblxuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gICdhbGwgb3V0Ym91bmQgcnVsZSBjYW5ub3QgYmUgYWRkZWQgYWZ0ZXIgY3JlYXRpb24nKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgY29uc3QgdnBjID0gbmV3IFZwYyhzdGFjaywgJ1ZQQycpO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IHNnID0gbmV3IFNlY3VyaXR5R3JvdXAoc3RhY2ssICdTRzEnLCB7IHZwYywgYWxsb3dBbGxPdXRib3VuZDogZmFsc2UgfSk7XG4gICAgdGVzdC50aHJvd3MoKCkgPT4ge1xuICAgICAgc2cuYWRkRWdyZXNzUnVsZShuZXcgQW55SVB2NCgpLCBuZXcgQWxsVHJhZmZpYygpLCAnQWxsIHRyYWZmaWMnKTtcbiAgICB9LCAvQ2Fubm90IGFkZC8pO1xuXG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ3BlZXIgYmV0d2VlbiBhbGwgdHlwZXMgb2YgcGVlcnMgYW5kIHBvcnQgcmFuZ2UgdHlwZXMnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKHVuZGVmaW5lZCwgJ1Rlc3RTdGFjaycsIHsgZW52OiB7IGFjY291bnQ6ICcxMjM0NTY3OCcsIHJlZ2lvbjogJ2R1bW15JyB9fSk7XG4gICAgY29uc3QgdnBjID0gbmV3IFZwYyhzdGFjaywgJ1ZQQycpO1xuICAgIGNvbnN0IHNnID0gbmV3IFNlY3VyaXR5R3JvdXAoc3RhY2ssICdTRycsIHsgdnBjIH0pO1xuXG4gICAgY29uc3QgcGVlcnMgPSBbXG4gICAgICBuZXcgU2VjdXJpdHlHcm91cChzdGFjaywgJ1BlZXJHcm91cCcsIHsgdnBjIH0pLFxuICAgICAgbmV3IEFueUlQdjQoKSxcbiAgICAgIG5ldyBBbnlJUHY2KCksXG4gICAgICBuZXcgUHJlZml4TGlzdCgncGwtMDEyMzQ1JyksXG4gICAgXTtcblxuICAgIGNvbnN0IHBvcnRzID0gW1xuICAgICAgbmV3IFRjcFBvcnQoMTIzNCksXG4gICAgICBuZXcgVGNwUG9ydChMYXp5Lm51bWJlclZhbHVlKHsgcHJvZHVjZTogKCkgPT4gNTAwMCB9KSksXG4gICAgICBuZXcgVGNwQWxsUG9ydHMoKSxcbiAgICAgIG5ldyBUY3BQb3J0UmFuZ2UoODAsIDkwKSxcbiAgICAgIG5ldyBVZHBQb3J0KDIzNDUpLFxuICAgICAgbmV3IFVkcFBvcnQoTGF6eS5udW1iZXJWYWx1ZSh7IHByb2R1Y2U6ICgpID0+IDc3NzcgfSkpLFxuICAgICAgbmV3IFVkcEFsbFBvcnRzKCksXG4gICAgICBuZXcgVWRwUG9ydFJhbmdlKDg1LCA5NSksXG4gICAgICBuZXcgSWNtcFR5cGVBbmRDb2RlKDUsIDEpLFxuICAgICAgbmV3IEljbXBBbGxUeXBlQ29kZXMoOCksXG4gICAgICBuZXcgSWNtcEFsbFR5cGVzQW5kQ29kZXMoKSxcbiAgICAgIG5ldyBJY21wUGluZygpLFxuICAgICAgbmV3IEFsbFRyYWZmaWMoKVxuICAgIF07XG5cbiAgICAvLyBXSEVOXG4gICAgZm9yIChjb25zdCBwZWVyIG9mIHBlZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHBvcnQgb2YgcG9ydHMpIHtcbiAgICAgICAgc2cuY29ubmVjdGlvbnMuYWxsb3dUbyhwZWVyLCBwb3J0KTtcbiAgICAgICAgc2cuY29ubmVjdGlvbnMuYWxsb3dGcm9tKHBlZXIsIHBvcnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRIRU4gLS0gbm8gY3Jhc2hcblxuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gICdpZiB0b2tlbnMgYXJlIHVzZWQgaW4gcG9ydHMsIGBjYW5JbmxpbmVSdWxlYCBzaG91bGQgYmUgZmFsc2UgdG8gYXZvaWQgY3ljbGVzJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCBwMSA9IExhenkubnVtYmVyVmFsdWUoeyBwcm9kdWNlOiAoKSA9PiA4MCB9KTtcbiAgICBjb25zdCBwMiA9IExhenkubnVtYmVyVmFsdWUoeyBwcm9kdWNlOiAoKSA9PiA1MDAwIH0pO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IHBvcnRzID0gW1xuICAgICAgbmV3IFRjcFBvcnQocDEpLFxuICAgICAgbmV3IFRjcFBvcnQocDIpLFxuICAgICAgbmV3IFRjcFBvcnRSYW5nZShwMSwgOTApLFxuICAgICAgbmV3IFRjcFBvcnRSYW5nZSg4MCwgcDIpLFxuICAgICAgbmV3IFRjcFBvcnRSYW5nZShwMSwgcDIpLFxuICAgICAgbmV3IFVkcFBvcnQocDEpLFxuICAgICAgbmV3IFVkcFBvcnRSYW5nZShwMSwgOTUpLFxuICAgICAgbmV3IFVkcFBvcnRSYW5nZSg4NSwgcDIpLFxuICAgICAgbmV3IFVkcFBvcnRSYW5nZShwMSwgcDIpLFxuICAgICAgbmV3IEljbXBUeXBlQW5kQ29kZShwMSwgMSksXG4gICAgICBuZXcgSWNtcFR5cGVBbmRDb2RlKDUsIHAxKSxcbiAgICAgIG5ldyBJY21wVHlwZUFuZENvZGUocDEsIHAyKSxcbiAgICAgIG5ldyBJY21wQWxsVHlwZUNvZGVzKHAxKSxcbiAgICBdO1xuXG4gICAgLy8gVEhFTlxuICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgcG9ydHMpIHtcbiAgICAgIHRlc3QuZXF1YWwocmFuZ2UuY2FuSW5saW5lUnVsZSwgZmFsc2UsIHJhbmdlLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHRlc3QuZG9uZSgpO1xuICB9XG59O1xuIl19