"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cdk_1 = require("@aws-cdk/cdk");
const connections_1 = require("./connections");
/**
 * A connection to and from a given IP range
 */
class CidrIPv4 {
    constructor(cidrIp) {
        this.cidrIp = cidrIp;
        this.canInlineRule = true;
        this.connections = new connections_1.Connections({ securityGroupRule: this });
        this.uniqueId = cidrIp;
    }
    /**
     * Produce the ingress rule JSON for the given connection
     */
    toIngressRuleJSON() {
        return { cidrIp: this.cidrIp };
    }
    /**
     * Produce the egress rule JSON for the given connection
     */
    toEgressRuleJSON() {
        return { cidrIp: this.cidrIp };
    }
}
exports.CidrIPv4 = CidrIPv4;
/**
 * Any IPv4 address
 */
class AnyIPv4 extends CidrIPv4 {
    constructor() {
        super("0.0.0.0/0");
    }
}
exports.AnyIPv4 = AnyIPv4;
/**
 * A connection to a from a given IPv6 range
 */
class CidrIPv6 {
    constructor(cidrIpv6) {
        this.cidrIpv6 = cidrIpv6;
        this.canInlineRule = true;
        this.connections = new connections_1.Connections({ securityGroupRule: this });
        this.uniqueId = cidrIpv6;
    }
    /**
     * Produce the ingress rule JSON for the given connection
     */
    toIngressRuleJSON() {
        return { cidrIpv6: this.cidrIpv6 };
    }
    /**
     * Produce the egress rule JSON for the given connection
     */
    toEgressRuleJSON() {
        return { cidrIpv6: this.cidrIpv6 };
    }
}
exports.CidrIPv6 = CidrIPv6;
/**
 * Any IPv6 address
 */
class AnyIPv6 extends CidrIPv6 {
    constructor() {
        super("::0/0");
    }
}
exports.AnyIPv6 = AnyIPv6;
/**
 * A prefix list
 *
 * Prefix lists are used to allow traffic to VPC-local service endpoints.
 *
 * For more information, see this page:
 *
 * https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-endpoints.html
 */
class PrefixList {
    constructor(prefixListId) {
        this.prefixListId = prefixListId;
        this.canInlineRule = false;
        this.connections = new connections_1.Connections({ securityGroupRule: this });
        this.uniqueId = prefixListId;
    }
    toIngressRuleJSON() {
        return { sourcePrefixListId: this.prefixListId };
    }
    toEgressRuleJSON() {
        return { destinationPrefixListId: this.prefixListId };
    }
}
exports.PrefixList = PrefixList;
/**
 * Protocol for use in Connection Rules
 */
var Protocol;
(function (Protocol) {
    Protocol["All"] = "-1";
    Protocol["Tcp"] = "tcp";
    Protocol["Udp"] = "udp";
    Protocol["Icmp"] = "icmp";
    Protocol["Icmpv6"] = "58";
})(Protocol = exports.Protocol || (exports.Protocol = {}));
/**
 * A single TCP port
 */
class TcpPort {
    constructor(port) {
        this.port = port;
        this.canInlineRule = !cdk_1.Token.isUnresolved(this.port);
    }
    toRuleJSON() {
        return {
            ipProtocol: Protocol.Tcp,
            fromPort: this.port,
            toPort: this.port
        };
    }
    toString() {
        return cdk_1.Token.isUnresolved(this.port) ? `{IndirectPort}` : this.port.toString();
    }
}
exports.TcpPort = TcpPort;
/**
 * A TCP port range
 */
class TcpPortRange {
    constructor(startPort, endPort) {
        this.startPort = startPort;
        this.endPort = endPort;
        this.canInlineRule = !cdk_1.Token.isUnresolved(this.startPort) && !cdk_1.Token.isUnresolved(this.endPort);
    }
    toRuleJSON() {
        return {
            ipProtocol: Protocol.Tcp,
            fromPort: this.startPort,
            toPort: this.endPort
        };
    }
    toString() {
        return `${this.startPort}-${this.endPort}`;
    }
}
exports.TcpPortRange = TcpPortRange;
/**
 * All TCP Ports
 */
class TcpAllPorts {
    constructor() {
        this.canInlineRule = true;
    }
    toRuleJSON() {
        return {
            ipProtocol: Protocol.Tcp,
            fromPort: 0,
            toPort: 65535
        };
    }
    toString() {
        return 'ALL PORTS';
    }
}
exports.TcpAllPorts = TcpAllPorts;
/**
 * A single UDP port
 */
class UdpPort {
    constructor(port) {
        this.port = port;
        this.canInlineRule = !cdk_1.Token.isUnresolved(this.port);
    }
    toRuleJSON() {
        return {
            ipProtocol: Protocol.Udp,
            fromPort: this.port,
            toPort: this.port
        };
    }
    toString() {
        const port = cdk_1.Token.isUnresolved(this.port) ? '{IndirectPort}' : this.port;
        return `UDP ${port}`;
    }
}
exports.UdpPort = UdpPort;
/**
 * A UDP port range
 */
class UdpPortRange {
    constructor(startPort, endPort) {
        this.startPort = startPort;
        this.endPort = endPort;
        this.canInlineRule = !cdk_1.Token.isUnresolved(this.startPort) && !cdk_1.Token.isUnresolved(this.endPort);
    }
    toRuleJSON() {
        return {
            ipProtocol: Protocol.Udp,
            fromPort: this.startPort,
            toPort: this.endPort
        };
    }
    toString() {
        return `UDP ${this.startPort}-${this.endPort}`;
    }
}
exports.UdpPortRange = UdpPortRange;
/**
 * All UDP Ports
 */
class UdpAllPorts {
    constructor() {
        this.canInlineRule = true;
    }
    toRuleJSON() {
        return {
            ipProtocol: Protocol.Udp,
            fromPort: 0,
            toPort: 65535
        };
    }
    toString() {
        return 'UDP ALL PORTS';
    }
}
exports.UdpAllPorts = UdpAllPorts;
/**
 * A set of matching ICMP Type & Code
 */
class IcmpTypeAndCode {
    constructor(type, code) {
        this.type = type;
        this.code = code;
        this.canInlineRule = !cdk_1.Token.isUnresolved(this.type) && !cdk_1.Token.isUnresolved(this.code);
    }
    toRuleJSON() {
        return {
            ipProtocol: Protocol.Icmp,
            fromPort: this.type,
            toPort: this.code
        };
    }
    toString() {
        return `ICMP Type ${this.type} Code ${this.code}`;
    }
}
exports.IcmpTypeAndCode = IcmpTypeAndCode;
/**
 * ICMP Ping traffic
 */
class IcmpPing {
    constructor() {
        this.canInlineRule = true;
    }
    toRuleJSON() {
        return {
            ipProtocol: Protocol.Icmp,
            fromPort: 8,
            toPort: -1
        };
    }
    toString() {
        return `ICMP PING`;
    }
}
exports.IcmpPing = IcmpPing;
/**
 * All ICMP Codes for a given ICMP Type
 */
class IcmpAllTypeCodes {
    constructor(type) {
        this.type = type;
        this.canInlineRule = !cdk_1.Token.isUnresolved(this.type);
    }
    toRuleJSON() {
        return {
            ipProtocol: Protocol.Icmp,
            fromPort: this.type,
            toPort: -1
        };
    }
    toString() {
        return `ICMP Type ${this.type}`;
    }
}
exports.IcmpAllTypeCodes = IcmpAllTypeCodes;
/**
 * All ICMP Types & Codes
 */
class IcmpAllTypesAndCodes {
    constructor() {
        this.canInlineRule = true;
    }
    toRuleJSON() {
        return {
            ipProtocol: Protocol.Icmp,
            fromPort: -1,
            toPort: -1
        };
    }
    toString() {
        return 'ALL ICMP';
    }
}
exports.IcmpAllTypesAndCodes = IcmpAllTypesAndCodes;
/**
 * All Traffic
 */
class AllTraffic {
    constructor() {
        this.canInlineRule = true;
    }
    toRuleJSON() {
        return {
            ipProtocol: '-1',
        };
    }
    toString() {
        return 'ALL TRAFFIC';
    }
}
exports.AllTraffic = AllTraffic;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjdXJpdHktZ3JvdXAtcnVsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInNlY3VyaXR5LWdyb3VwLXJ1bGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxzQ0FBcUM7QUFDckMsK0NBQTBEO0FBMkIxRDs7R0FFRztBQUNILE1BQWEsUUFBUTtJQUtuQixZQUE2QixNQUFjO1FBQWQsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUozQixrQkFBYSxHQUFHLElBQUksQ0FBQztRQUNyQixnQkFBVyxHQUFnQixJQUFJLHlCQUFXLENBQUMsRUFBRSxpQkFBaUIsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBSXRGLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7T0FFRztJQUNJLGlCQUFpQjtRQUN0QixPQUFPLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUNqQyxDQUFDO0lBQ0Q7O09BRUc7SUFDSSxnQkFBZ0I7UUFDckIsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDakMsQ0FBQztDQUNGO0FBckJELDRCQXFCQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxPQUFRLFNBQVEsUUFBUTtJQUNuQztRQUNFLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNyQixDQUFDO0NBQ0Y7QUFKRCwwQkFJQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxRQUFRO0lBS25CLFlBQTZCLFFBQWdCO1FBQWhCLGFBQVEsR0FBUixRQUFRLENBQVE7UUFKN0Isa0JBQWEsR0FBRyxJQUFJLENBQUM7UUFDckIsZ0JBQVcsR0FBZ0IsSUFBSSx5QkFBVyxDQUFDLEVBQUUsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUl0RixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztJQUMzQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxpQkFBaUI7UUFDdEIsT0FBTyxF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QUM7SUFXdkMsQ0FBQztJQVRRLFVBQVU7UUFDZixPQUFPO1lBQ0wsVUFBVSxFQUFFLElBQUk7U0FDakIsQ0FBQztJQUNKLENBQUM7SUFFTSxRQUFRO1FBQ2IsT0FBTyxhQUFhLENBQUM7SUFDdkIsQ0FBQztDQUNGO0FBWkQsZ0NBWUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUb2tlbiB9IGZyb20gJ0Bhd3MtY2RrL2Nkayc7XG5pbXBvcnQgeyBDb25uZWN0aW9ucywgSUNvbm5lY3RhYmxlIH0gZnJvbSBcIi4vY29ubmVjdGlvbnNcIjtcblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGNsYXNzZXMgdGhhdCBwcm92aWRlIHRoZSBwZWVyLXNwZWNpZmljYXRpb24gcGFydHMgb2YgYSBzZWN1cml0eSBncm91cCBydWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVNlY3VyaXR5R3JvdXBSdWxlIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHJ1bGUgY2FuIGJlIGlubGluZWQgaW50byBhIFNlY3VyaXR5R3JvdXAgb3Igbm90XG4gICAqL1xuICByZWFkb25seSBjYW5JbmxpbmVSdWxlOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGNvbm5lY3Rpb24gcGVlclxuICAgKi9cbiAgcmVhZG9ubHkgdW5pcXVlSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogUHJvZHVjZSB0aGUgaW5ncmVzcyBydWxlIEpTT04gZm9yIHRoZSBnaXZlbiBjb25uZWN0aW9uXG4gICAqL1xuICB0b0luZ3Jlc3NSdWxlSlNPTigpOiBhbnk7XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgdGhlIGVncmVzcyBydWxlIEpTT04gZm9yIHRoZSBnaXZlbiBjb25uZWN0aW9uXG4gICAqL1xuICB0b0VncmVzc1J1bGVKU09OKCk6IGFueTtcbn1cblxuLyoqXG4gKiBBIGNvbm5lY3Rpb24gdG8gYW5kIGZyb20gYSBnaXZlbiBJUCByYW5nZVxuICovXG5leHBvcnQgY2xhc3MgQ2lkcklQdjQgaW1wbGVtZW50cyBJU2VjdXJpdHlHcm91cFJ1bGUsIElDb25uZWN0YWJsZSB7XG4gIHB1YmxpYyByZWFkb25seSBjYW5JbmxpbmVSdWxlID0gdHJ1ZTtcbiAgcHVibGljIHJlYWRvbmx5IGNvbm5lY3Rpb25zOiBDb25uZWN0aW9ucyA9IG5ldyBDb25uZWN0aW9ucyh7IHNlY3VyaXR5R3JvdXBSdWxlOiB0aGlzIH0pO1xuICBwdWJsaWMgcmVhZG9ubHkgdW5pcXVlSWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNpZHJJcDogc3RyaW5nKSB7XG4gICAgdGhpcy51bmlxdWVJZCA9IGNpZHJJcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlIHRoZSBpbmdyZXNzIHJ1bGUgSlNPTiBmb3IgdGhlIGdpdmVuIGNvbm5lY3Rpb25cbiAgICovXG4gIHB1YmxpYyB0b0luZ3Jlc3NSdWxlSlNPTigpOiBhbnkge1xuICAgIHJldHVybiB7IGNpZHJJcDogdGhpcy5jaWRySXAgfTtcbiAgfVxuICAvKipcbiAgICogUHJvZHVjZSB0aGUgZWdyZXNzIHJ1bGUgSlNPTiBmb3IgdGhlIGdpdmVuIGNvbm5lY3Rpb25cbiAgICovXG4gIHB1YmxpYyB0b0VncmVzc1J1bGVKU09OKCk6IGFueSB7XG4gICAgcmV0dXJuIHsgY2lkcklwOiB0aGlzLmNpZHJJcCB9O1xuICB9XG59XG5cbi8qKlxuICogQW55IElQdjQgYWRkcmVzc1xuICovXG5leHBvcnQgY2xhc3MgQW55SVB2NCBleHRlbmRzIENpZHJJUHY0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCIwLjAuMC4wLzBcIik7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbm5lY3Rpb24gdG8gYSBmcm9tIGEgZ2l2ZW4gSVB2NiByYW5nZVxuICovXG5leHBvcnQgY2xhc3MgQ2lkcklQdjYgaW1wbGVtZW50cyBJU2VjdXJpdHlHcm91cFJ1bGUsIElDb25uZWN0YWJsZSB7XG4gIHB1YmxpYyByZWFkb25seSBjYW5JbmxpbmVSdWxlID0gdHJ1ZTtcbiAgcHVibGljIHJlYWRvbmx5IGNvbm5lY3Rpb25zOiBDb25uZWN0aW9ucyA9IG5ldyBDb25uZWN0aW9ucyh7IHNlY3VyaXR5R3JvdXBSdWxlOiB0aGlzIH0pO1xuICBwdWJsaWMgcmVhZG9ubHkgdW5pcXVlSWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNpZHJJcHY2OiBzdHJpbmcpIHtcbiAgICB0aGlzLnVuaXF1ZUlkID0gY2lkcklwdjY7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZSB0aGUgaW5ncmVzcyBydWxlIEpTT04gZm9yIHRoZSBnaXZlbiBjb25uZWN0aW9uXG4gICAqL1xuICBwdWJsaWMgdG9JbmdyZXNzUnVsZUpTT04oKTogYW55IHtcbiAgICByZXR1cm4geyBjaWRySXB2NjogdGhpcy5jaWRySXB2NiB9O1xuICB9XG4gIC8qKlxuICAgKiBQcm9kdWNlIHRoZSBlZ3Jlc3MgcnVsZSBKU09OIGZvciB0aGUgZ2l2ZW4gY29ubmVjdGlvblxuICAgKi9cbiAgcHVibGljIHRvRWdyZXNzUnVsZUpTT04oKTogYW55IHtcbiAgICByZXR1cm4geyBjaWRySXB2NjogdGhpcy5jaWRySXB2NiB9O1xuICB9XG59XG5cbi8qKlxuICogQW55IElQdjYgYWRkcmVzc1xuICovXG5leHBvcnQgY2xhc3MgQW55SVB2NiBleHRlbmRzIENpZHJJUHY2IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCI6OjAvMFwiKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgcHJlZml4IGxpc3RcbiAqXG4gKiBQcmVmaXggbGlzdHMgYXJlIHVzZWQgdG8gYWxsb3cgdHJhZmZpYyB0byBWUEMtbG9jYWwgc2VydmljZSBlbmRwb2ludHMuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGlzIHBhZ2U6XG4gKlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblZQQy9sYXRlc3QvVXNlckd1aWRlL3ZwYy1lbmRwb2ludHMuaHRtbFxuICovXG5leHBvcnQgY2xhc3MgUHJlZml4TGlzdCBpbXBsZW1lbnRzIElTZWN1cml0eUdyb3VwUnVsZSwgSUNvbm5lY3RhYmxlIHtcbiAgcHVibGljIHJlYWRvbmx5IGNhbklubGluZVJ1bGUgPSBmYWxzZTtcbiAgcHVibGljIHJlYWRvbmx5IGNvbm5lY3Rpb25zOiBDb25uZWN0aW9ucyA9IG5ldyBDb25uZWN0aW9ucyh7IHNlY3VyaXR5R3JvdXBSdWxlOiB0aGlzIH0pO1xuICBwdWJsaWMgcmVhZG9ubHkgdW5pcXVlSWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByZWZpeExpc3RJZDogc3RyaW5nKSB7XG4gICAgdGhpcy51bmlxdWVJZCA9IHByZWZpeExpc3RJZDtcbiAgfVxuXG4gIHB1YmxpYyB0b0luZ3Jlc3NSdWxlSlNPTigpOiBhbnkge1xuICAgIHJldHVybiB7IHNvdXJjZVByZWZpeExpc3RJZDogdGhpcy5wcmVmaXhMaXN0SWQgfTtcbiAgfVxuXG4gIHB1YmxpYyB0b0VncmVzc1J1bGVKU09OKCk6IGFueSB7XG4gICAgcmV0dXJuIHsgZGVzdGluYXRpb25QcmVmaXhMaXN0SWQ6IHRoaXMucHJlZml4TGlzdElkIH07XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGNsYXNzZXMgdGhhdCBwcm92aWRlIHRoZSBjb25uZWN0aW9uLXNwZWNpZmljYXRpb24gcGFydHMgb2YgYSBzZWN1cml0eSBncm91cCBydWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVBvcnRSYW5nZSB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBydWxlIGNvbnRhaW5pbmcgdGhpcyBwb3J0IHJhbmdlIGNhbiBiZSBpbmxpbmVkIGludG8gYSBzZWN1cml0eWdyb3VwIG9yIG5vdC5cbiAgICovXG4gIHJlYWRvbmx5IGNhbklubGluZVJ1bGU6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgdGhlIGluZ3Jlc3MvZWdyZXNzIHJ1bGUgSlNPTiBmb3IgdGhlIGdpdmVuIGNvbm5lY3Rpb25cbiAgICovXG4gIHRvUnVsZUpTT04oKTogYW55O1xufVxuXG4vKipcbiAqIFByb3RvY29sIGZvciB1c2UgaW4gQ29ubmVjdGlvbiBSdWxlc1xuICovXG5leHBvcnQgZW51bSBQcm90b2NvbCB7XG4gIEFsbCA9ICctMScsXG4gIFRjcCA9ICd0Y3AnLFxuICBVZHAgPSAndWRwJyxcbiAgSWNtcCA9ICdpY21wJyxcbiAgSWNtcHY2ID0gJzU4Jyxcbn1cblxuLyoqXG4gKiBBIHNpbmdsZSBUQ1AgcG9ydFxuICovXG5leHBvcnQgY2xhc3MgVGNwUG9ydCBpbXBsZW1lbnRzIElQb3J0UmFuZ2Uge1xuICBwdWJsaWMgcmVhZG9ubHkgY2FuSW5saW5lUnVsZSA9ICFUb2tlbi5pc1VucmVzb2x2ZWQodGhpcy5wb3J0KTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHBvcnQ6IG51bWJlcikge1xuICB9XG5cbiAgcHVibGljIHRvUnVsZUpTT04oKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXBQcm90b2NvbDogUHJvdG9jb2wuVGNwLFxuICAgICAgZnJvbVBvcnQ6IHRoaXMucG9ydCxcbiAgICAgIHRvUG9ydDogdGhpcy5wb3J0XG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gVG9rZW4uaXNVbnJlc29sdmVkKHRoaXMucG9ydCkgPyBge0luZGlyZWN0UG9ydH1gIDogdGhpcy5wb3J0LnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIFRDUCBwb3J0IHJhbmdlXG4gKi9cbmV4cG9ydCBjbGFzcyBUY3BQb3J0UmFuZ2UgaW1wbGVtZW50cyBJUG9ydFJhbmdlIHtcbiAgcHVibGljIHJlYWRvbmx5IGNhbklubGluZVJ1bGUgPSAhVG9rZW4uaXNVbnJlc29sdmVkKHRoaXMuc3RhcnRQb3J0KSAmJiAhVG9rZW4uaXNVbnJlc29sdmVkKHRoaXMuZW5kUG9ydCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBzdGFydFBvcnQ6IG51bWJlciwgcHJpdmF0ZSByZWFkb25seSBlbmRQb3J0OiBudW1iZXIpIHtcbiAgfVxuXG4gIHB1YmxpYyB0b1J1bGVKU09OKCk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlwUHJvdG9jb2w6IFByb3RvY29sLlRjcCxcbiAgICAgIGZyb21Qb3J0OiB0aGlzLnN0YXJ0UG9ydCxcbiAgICAgIHRvUG9ydDogdGhpcy5lbmRQb3J0XG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5zdGFydFBvcnR9LSR7dGhpcy5lbmRQb3J0fWA7XG4gIH1cbn1cblxuLyoqXG4gKiBBbGwgVENQIFBvcnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBUY3BBbGxQb3J0cyBpbXBsZW1lbnRzIElQb3J0UmFuZ2Uge1xuICBwdWJsaWMgcmVhZG9ubHkgY2FuSW5saW5lUnVsZSA9IHRydWU7XG5cbiAgcHVibGljIHRvUnVsZUpTT04oKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXBQcm90b2NvbDogUHJvdG9jb2wuVGNwLFxuICAgICAgZnJvbVBvcnQ6IDAsXG4gICAgICB0b1BvcnQ6IDY1NTM1XG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0FMTCBQT1JUUyc7XG4gIH1cbn1cblxuLyoqXG4gKiBBIHNpbmdsZSBVRFAgcG9ydFxuICovXG5leHBvcnQgY2xhc3MgVWRwUG9ydCBpbXBsZW1lbnRzIElQb3J0UmFuZ2Uge1xuICBwdWJsaWMgcmVhZG9ubHkgY2FuSW5saW5lUnVsZSA9ICFUb2tlbi5pc1VucmVzb2x2ZWQodGhpcy5wb3J0KTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHBvcnQ6IG51bWJlcikge1xuICB9XG5cbiAgcHVibGljIHRvUnVsZUpTT04oKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXBQcm90b2NvbDogUHJvdG9jb2wuVWRwLFxuICAgICAgZnJvbVBvcnQ6IHRoaXMucG9ydCxcbiAgICAgIHRvUG9ydDogdGhpcy5wb3J0XG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICBjb25zdCBwb3J0ID0gVG9rZW4uaXNVbnJlc29sdmVkKHRoaXMucG9ydCkgPyAne0luZGlyZWN0UG9ydH0nIDogdGhpcy5wb3J0O1xuICAgIHJldHVybiBgVURQICR7cG9ydH1gO1xuICB9XG59XG5cbi8qKlxuICogQSBVRFAgcG9ydCByYW5nZVxuICovXG5leHBvcnQgY2xhc3MgVWRwUG9ydFJhbmdlIGltcGxlbWVudHMgSVBvcnRSYW5nZSB7XG4gIHB1YmxpYyByZWFkb25seSBjYW5JbmxpbmVSdWxlID0gIVRva2VuLmlzVW5yZXNvbHZlZCh0aGlzLnN0YXJ0UG9ydCkgJiYgIVRva2VuLmlzVW5yZXNvbHZlZCh0aGlzLmVuZFBvcnQpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc3RhcnRQb3J0OiBudW1iZXIsIHByaXZhdGUgcmVhZG9ubHkgZW5kUG9ydDogbnVtYmVyKSB7XG4gIH1cblxuICBwdWJsaWMgdG9SdWxlSlNPTigpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICBpcFByb3RvY29sOiBQcm90b2NvbC5VZHAsXG4gICAgICBmcm9tUG9ydDogdGhpcy5zdGFydFBvcnQsXG4gICAgICB0b1BvcnQ6IHRoaXMuZW5kUG9ydFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBVRFAgJHt0aGlzLnN0YXJ0UG9ydH0tJHt0aGlzLmVuZFBvcnR9YDtcbiAgfVxufVxuXG4vKipcbiAqIEFsbCBVRFAgUG9ydHNcbiAqL1xuZXhwb3J0IGNsYXNzIFVkcEFsbFBvcnRzIGltcGxlbWVudHMgSVBvcnRSYW5nZSB7XG4gIHB1YmxpYyByZWFkb25seSBjYW5JbmxpbmVSdWxlID0gdHJ1ZTtcblxuICBwdWJsaWMgdG9SdWxlSlNPTigpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICBpcFByb3RvY29sOiBQcm90b2NvbC5VZHAsXG4gICAgICBmcm9tUG9ydDogMCxcbiAgICAgIHRvUG9ydDogNjU1MzVcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnVURQIEFMTCBQT1JUUyc7XG4gIH1cbn1cblxuLyoqXG4gKiBBIHNldCBvZiBtYXRjaGluZyBJQ01QIFR5cGUgJiBDb2RlXG4gKi9cbmV4cG9ydCBjbGFzcyBJY21wVHlwZUFuZENvZGUgaW1wbGVtZW50cyBJUG9ydFJhbmdlIHtcbiAgcHVibGljIHJlYWRvbmx5IGNhbklubGluZVJ1bGUgPSAhVG9rZW4uaXNVbnJlc29sdmVkKHRoaXMudHlwZSkgJiYgIVRva2VuLmlzVW5yZXNvbHZlZCh0aGlzLmNvZGUpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgdHlwZTogbnVtYmVyLCBwcml2YXRlIHJlYWRvbmx5IGNvZGU6IG51bWJlcikge1xuICB9XG5cbiAgcHVibGljIHRvUnVsZUpTT04oKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXBQcm90b2NvbDogUHJvdG9jb2wuSWNtcCxcbiAgICAgIGZyb21Qb3J0OiB0aGlzLnR5cGUsXG4gICAgICB0b1BvcnQ6IHRoaXMuY29kZVxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBJQ01QIFR5cGUgJHt0aGlzLnR5cGV9IENvZGUgJHt0aGlzLmNvZGV9YDtcbiAgfVxufVxuXG4vKipcbiAqIElDTVAgUGluZyB0cmFmZmljXG4gKi9cbmV4cG9ydCBjbGFzcyBJY21wUGluZyBpbXBsZW1lbnRzIElQb3J0UmFuZ2Uge1xuICBwdWJsaWMgcmVhZG9ubHkgY2FuSW5saW5lUnVsZSA9IHRydWU7XG5cbiAgcHVibGljIHRvUnVsZUpTT04oKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXBQcm90b2NvbDogUHJvdG9jb2wuSWNtcCxcbiAgICAgIGZyb21Qb3J0OiA4LFxuICAgICAgdG9Qb3J0OiAtMVxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBJQ01QIFBJTkdgO1xuICB9XG59XG5cbi8qKlxuICogQWxsIElDTVAgQ29kZXMgZm9yIGEgZ2l2ZW4gSUNNUCBUeXBlXG4gKi9cbmV4cG9ydCBjbGFzcyBJY21wQWxsVHlwZUNvZGVzIGltcGxlbWVudHMgSVBvcnRSYW5nZSB7XG4gIHB1YmxpYyByZWFkb25seSBjYW5JbmxpbmVSdWxlID0gIVRva2VuLmlzVW5yZXNvbHZlZCh0aGlzLnR5cGUpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgdHlwZTogbnVtYmVyKSB7XG4gIH1cblxuICBwdWJsaWMgdG9SdWxlSlNPTigpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICBpcFByb3RvY29sOiBQcm90b2NvbC5JY21wLFxuICAgICAgZnJvbVBvcnQ6IHRoaXMudHlwZSxcbiAgICAgIHRvUG9ydDogLTFcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgSUNNUCBUeXBlICR7dGhpcy50eXBlfWA7XG4gIH1cbn1cblxuLyoqXG4gKiBBbGwgSUNNUCBUeXBlcyAmIENvZGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBJY21wQWxsVHlwZXNBbmRDb2RlcyBpbXBsZW1lbnRzIElQb3J0UmFuZ2Uge1xuICBwdWJsaWMgcmVhZG9ubHkgY2FuSW5saW5lUnVsZSA9IHRydWU7XG5cbiAgcHVibGljIHRvUnVsZUpTT04oKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXBQcm90b2NvbDogUHJvdG9jb2wuSWNtcCxcbiAgICAgIGZyb21Qb3J0OiAtMSxcbiAgICAgIHRvUG9ydDogLTFcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnQUxMIElDTVAnO1xuICB9XG59XG5cbi8qKlxuICogQWxsIFRyYWZmaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEFsbFRyYWZmaWMgaW1wbGVtZW50cyBJUG9ydFJhbmdlIHtcbiAgcHVibGljIHJlYWRvbmx5IGNhbklubGluZVJ1bGUgPSB0cnVlO1xuXG4gIHB1YmxpYyB0b1J1bGVKU09OKCk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlwUHJvdG9jb2w6ICctMScsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0FMTCBUUkFGRklDJztcbiAgfVxufVxuIl19